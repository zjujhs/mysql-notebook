## 笛卡尔积

有两个集合，分别为A和B，其中A集合有m个元素，B集合有n个元素，那么A与B两集合的笛卡尔积是一个有m*n个元素的集合，集合中每个元素都是一个二元组，二元组内的两个元素分别为A中元素与B中元素。

> 例：
>
> A = {a, b, c}, B = {1, 2, 3, 4}
>
> A × B = {(a, 1), (a, 2), (a, 3), (a, 4), (b, 1), (b, 2), (b, 3), (b, 4), (c, 1), (c, 2), (c, 3), (c, 4)}

MySQL的join操作是基于笛卡尔积的，可以通过`INNER JOIN`或`CROSS JOIN`得到笛卡尔积。

## 过滤筛选

`ON`关键字用于筛选笛卡尔积的结果。如`INNER JOIN`时，只有满足`ON`条件的行才能被纳入到最终的查询结果中。

## 驱动表与被驱动表

做`JOIN`操作的两张表会被分为驱动表和被驱动表。其中，驱动表被全表扫描，并在被驱动表中查找满足`ON`条件的行。

尽管`left join`将左边的表作为驱动表，`right join`将右面的表作为驱动表，但MySQL优化器会对驱动表有一个选择的过程。

- 若希望固定驱动表，可使用`straight_join`关键字做连接操作，固定左侧表为驱动表

MySQL优化器选择驱动表的依据：小表驱动大表。原因有很多，比如小表更容易被加载到内存当中，而大表需要多次IO操作；再比如小表可以减少关联比较次数，等等。处于上述多种原因，小表驱动大表能够带来更好的查询性能。

> EXPLAIN查询执行计划时，位于上方的表是驱动表。

由于驱动表会被全表扫描，因此驱动表上建立的索引无法被使用。但被驱动表上的索引可以被使用，因此我们应当对被驱动表建立适当的索引来加速关联比较过程。

